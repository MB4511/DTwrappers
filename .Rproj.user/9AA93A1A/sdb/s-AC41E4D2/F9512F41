{
    "collab_server" : "",
    "contents" : "rm(list=ls())\n\nsource(\"check.dt.exists.R\")\nsource(\"check.dt.status.R\")\nsource(\"create.dt.statement.R\")\nsource(\"eval.dt.statement.R\")\nsource(\"reduce.vector.expression.R\")\nsource(\"dt.choose.rows, dt.choose.cols, and dt.count.rows.R\")\nsource(\"dt.first.k.rows_and_dt.last.k.rows.R\")\nsource(\"dt.define.variable.R\")\nsource(\"dt.remove.variables.R\")\nsource(\"dt.calculate.R\")\nsource(\"dt.sort.R\")\n\n# Set-up\nRNGversion(vstr = 3.6)\nset.seed(seed = 813)\n\nn <- nrow(iris)\ndt.name <- \"dat\"\ndat <- data.table::as.data.table(x = iris[sample(x = 1:n, size = n, replace = F),])\n\n\n# Filter the data to the first 3 rows using a numeric vector for the.filter.\ndt.choose.rows(dt.name = \"dat\", the.filter = \"1:3\")\n\n# the.filter can also be a numeric vector:\ndt.choose.rows(dt.name = \"dat\", the.filter = 1:3)\n\n# Setting return.as = \"code\" displays only the code.\ndt.choose.rows(dt.name = \"dat\", the.filter = c(1:3, 5:6), return.as = \"code\")\n\n# Setting return.as = \"all\" shows both the result and the code. Notice also that the.filter's selected indices of c(1:3, 4:6) will be reduced to the expression 1:6.\ndt.choose.rows(dt.name = \"dat\", the.filter = c(1:3, 4:6), return.as = \"all\")\n\n\ndt.choose.rows(dt.name = \"dat\", the.filter = \"c(1:3, 17:32)\", return.as = \"code\")\n\n# the.filter can also have a logical comparison by specifying \"Sepal.Length < 4.4\" \ndt.choose.rows(dt.name = \"dat\", the.filter = \"Sepal.Length < 4.4\", return.as = \"all\")\n\n# the.filter can also be set up as an expression statement with expression(Sepal.Length < 4.4) \ndt.choose.rows(dt.name = \"dat\", the.filter = expression(Sepal.Length < 4.4), return.as = \"all\")\n\n# the.filter could be specified with a statement that produces a logical vector of TRUE or FALSE values.\ndt.choose.rows(dt.name = \"dat\", the.filter = \"sample(x = c(TRUE, FALSE), size = nrow(dat), replace = T)\", return.as = \"code\")\n\n# When a vector of TRUE/FALSE values are supplied to the.filter, the respective row indices are used to filter the data.\ndt.choose.rows(dt.name = \"dat\", the.filter = rep.int(x = c(TRUE, rep.int(x = FALSE, times = 9)), times = n/10), return.as = \"code\")\n\n# Adding a new variable to convey the category of flower.  Note that directly providing the values requires using specification = \"by.value\".\ndt.define.variable(dt.name = \"dat\", variable.name = \"Category\", the.values = \"iris\", return.as = \"code\", specification = \"by.value\")\n\n# Just for fun, we can add a random Noise variable from a standard normal distribution.  Note that adding values using a calculation should be paired with specification = \"by.expression\" (the default value)\ndt.define.variable(dt.name = \"dat\", variable.name = \"Noise\", the.values = \"rnorm(n = nrow(dat))\", specification = \"by.expression\", return.as = \"all\")\n\n# Adding a new variable to show the maximum Sepal Length in each Species.  Since this is specified with a calculated expression, we use specification = \"by.epxression\".  We also set grouping.variables = \"Species\" to allow for a separate calculation of the maximum speal length for each species.  Using sortby.group = TRUE will create a sorted data set by the grouping.variables.\ndt.define.variable(dt.name = \"dat\", variable.name = \"Max_Sepal_Length_Species\", the.values = \"max(Sepal.Length)\", specification = \"by.expression\", grouping.variables = \"Species\", sortby.group = TRUE, return.as = \"all\")\n\n\ndt.define.variable(dt.name = \"dat\", variable.name = \"v_name\", the.values = \"substring(text = Species, first = 1, last = 1) == 'v'\", return.as = \"all\")\ndt.define.variable(dt.name = \"dat\", variable.name = \"Above Average Sepal Length\", the.values = \"Sepal.Length > mean(Sepal.Length)\", return.as = \"all\")\n\n\n# Now we turn to the problem of counting the rows in a data set using dt.count.rows.  We'll start with the overall total.  This is returned as a numeric value unless grouping statements are added.\ndt.count.rows(dt.name = \"dat\", return.as = \"all\")\n\n# You can also change the name of the variable showing the count.  This creates a data.table output.\ndt.count.rows(dt.name = \"dat\", count.name = \"Total Rows\", return.as = \"all\")\n\n# We can count the number of rows after filtering has taken place\ndt.count.rows(dt.name = \"dat\", the.filter = 1:5, return.as = \"all\")\ndt.count.rows(dt.name = \"dat\", the.filter = \"c(1:5, 7:8)\", return.as = \"all\")\ndt.count.rows(dt.name = \"dat\", the.filter = \"Sepal.Length < 5\", count.name = \"Rows with Sepal.Length < 5\", return.as = \"all\")\n\n\n# Group by a variable defined by column index:\ndt.count.rows(dt.name = \"dat\", grouping.variables = 5, return.as = \"all\")\n\n# Group by a variable defined by column name.  Note that using sortby.group = TRUE (the default value) will sort the resulting counts in order of the grouping.variables (a keyby step).\ndt.count.rows(dt.name = \"dat\", grouping.variables = \"Species\", sortby.group = T, return.as = \"all\")\n\n# Using sortby.group = F results in a table that is not sorted based on the grouping variables.  The resulting table shows up according to the order in which these values appear in the original data (a by step).\ndt.count.rows(dt.name = \"dat\", grouping.variables = c(\"Species\", \"Above Average Sepal Length\"), sortby.group = F, return.as = \"all\")\n\n# Counts grouped by both existing variables (Species) and a newly defined calculation of whether the Petal Width is below average in width.\ndt.count.rows(dt.name = \"dat\", grouping.variables = c(\"Species\", \"`Below Average Petal Width` = (Petal.Width < mean(Petal.Width))\"), return.as = \"all\")\n\ndt.count.rows(dt.name = \"dat\", grouping.variables = \"`Below Average Petal Width` = (Petal.Width < mean(Petal.Width))\", return.as = \"all\")\n\n\n# We can also remove variables from the data.\ndt.remove.variables(dt.name = \"dat\", the.variables = c(\"v_name\", \"Above Average Sepal Length\"), return.as = \"all\")\n\n\n# Select all of the variables.  If \".\" is included in the.variables, all of the column names are selected.\ndt.choose.cols(dt.name = \"dat\", the.variables = \".\", the.filter = \"1:3\", return.as = \"all\")\n\n# Selecting specific variables.\ndt.choose.cols(dt.name = \"dat\", the.variables = c(\"Species\", \"Sepal.Length\"), the.filter = \"1:3\", return.as = \"all\")\n\n# Select up to the first two rows for each Species\ndt.choose.cols(dt.name = \"dat\", the.variables = c(\"Sepal.Length\", \"Sepal.Width\"), grouping.variables = \"Species\", first.k = 2, return.as = \"all\")\n\n# Select up to the last two rows for each Species\ndt.choose.cols(dt.name = \"dat\", the.variables = c(\"Sepal.Length\", \"Sepal.Width\"), grouping.variables = \"Species\", last.k = 2, return.as = \"all\")\n\n# Select the second through fourth row for each species\ndt.choose.cols(dt.name = \"dat\", the.variables = c(\"Sepal.Length\", \"Sepal.Width\"), grouping.variables = \"Species\", row.indices = 2:4, return.as = \"all\")\n\ndt.choose.cols(dt.name = \"dat\", the.variables = c(\"Sepal.Length\", \"Sepal.Width\"), grouping.variables = \"Species\", row.indices = c(1:2, 3:4), return.as = \"all\")\n\n\n# dt.calculate is used to apply a set of functions to each specified variable.\ndt.calculate(dt.name = \"dat\", the.variables = c(\"Sepal.Length\"), the.functions = c(\"mean\", \"sd\"), table.format = \"long\", return.as = \"all\")\n\n# Filtering and grouping may also be used:\ndt.calculate(dt.name = \"dat\", the.variables = c(\"Sepal.Length\"), the.functions = c(\"mean\", \"sd\"), the.filter = \"Sepal.Length < 0.9 * Max_Sepal_Length_Species\", grouping.variables = \"Species\", table.format = \"long\", return.as = \"all\")\n\n# Selecting table.format = \"wide\" places the results into columns.\ndt.calculate(dt.name = \"dat\", the.variables = c(\"Sepal.Length\"), the.functions = c(\"mean\", \"sd\"), table.format = \"wide\", return.as = \"all\")\n\n\n# You can also supply additional parameters to the functions.  For instance, na.rm = T removes missing values in the mean and sd calculations:\ndt.calculate(dt.name = \"dat\", the.variables = c(\"Sepal.Length\", \"Sepal.Width\"), the.functions = c(\"mean\", \"sd\"), table.format = \"long\", other.params = \"na.rm = T\", return.as = \"all\")\n\n\n# Here we introduce a customized function.  The triple mean calculates 3 times the average.\n`triple mean` <- function(x, na.rm = T){\n  return(3 * mean(x = x, na.rm = na.rm))\n}\n\n# Customized functions can then be called in the.functions just like established methods.\ndt.calculate(dt.name = \"dat\", the.variables = c(\"Sepal.Length\", \"Sepal.Width\"), the.functions = c(\"mean\", \"sd\", \"triple mean\"), grouping.variables = \"Species\", table.format = \"long\", return.as = \"all\")\n\n\n# Adding filtering and customized grouping statements.\ndt.calculate(dt.name = \"dat\", the.variables = c(\"Sepal.Width\", \"Petal.Width\"), the.functions = c(\"mean\", \"sd\", \"triple mean\"), the.filter = \"Sepal.Length < 6\", grouping.variables = c(\"Below_Average_Sepal_Length = (Sepal.Length < mean(Sepal.Length))\"), table.format = \"long\", return.as = \"all\")\n\n\n## This section uses dt.calculate to perform calculations that involve all of the selected variables.\n\n## rowSums\ndt.calculate(dt.name = \"dat\", the.variables = c(\"Sepal.Width\", \"Petal.Width\"), the.functions = c(\"rowSums\", \"rowMeans\"), individual.variables = F)\n\n## linear regression (no grouping allowed)\ndt.calculate(dt.name = \"dat\", the.functions = \"lm\", other.params = \"formula = Sepal.Length ~ Sepal.Width + Petal.Length + Petal.Width\", return.as = \"all\", individual.variables = F, output.as.table = F)\n\n\n## linear regression -- stratified modeling by group with a function to extract the summary of the estimated coefficients.\n\nget.lm.coefs <- function(formula, data){\n  require(data.table)\n  mod <- lm(formula = formula, data = data)\n  the.coefs <- as.data.table(x = summary(mod)$coefficients, keep.rownames = TRUE)\n  setnames(x = the.coefs, old = \"rn\", new = \"Variable\")\n  return(the.coefs)\n}\n\ndt.calculate(dt.name = \"dat\", the.functions = \"get.lm.coefs\", grouping.variables = \"Species\", other.params = \"formula = Sepal.Length ~ Sepal.Width + Petal.Length + Petal.Width\", return.as = \"all\", individual.variables = F, add.function.name = F)\n\n# A data set can be sorted by specifying the variables to group by\ndt.sort(dt.name = \"dat\", sorting.variables = c(\"Species\", \"Sepal.Length\"), sort.increasing = c(F), return.as = \"all\")\n\n# Sorting can be controlled with sort.increasing.  Values of TRUE will sort in increasing order and FALSE in decreasing order for the corresponding entry of sorting.variables.\ndt.sort(dt.name = \"dat\", sorting.variables = c(\"Species\", \"Sepal.Length\"), sort.increasing = c(T, F), return.as = \"all\")\n\n\ndt.remove.variables(dt.name = \"dat\", the.variables = c(\"Noise\"), return.as = \"all\")\n\n\ndt.count.rows(dt.name = 'dat', the.filter = \"Petal.Length >6\")",
    "created" : 1606083860610.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3276431426",
    "id" : "F9512F41",
    "lastKnownWriteTime" : 1606065293,
    "last_content_update" : 1607304891319,
    "path" : "~/Desktop/DTwrappers Draft/example.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}