{
    "collab_server" : "",
    "contents" : "# Internal Function\n# description:  Creates a data.table coding statement as a character string based upon its components -- the i.statement, j.statement, and the list of grouping.variables.\n\n# dt.name:  a character vector including either a) the name of the data.table object on which to compute the given statements, or b) a sequence of chained data.table calls onto which another statement will be chained, such as \"dt[Age < 50, .(Gender, Age, Region)]\".  Then the i.statement, j.statement, and by.statement can be subsequently chained, e.g. to generate \"dt[Age < 50, .(Gender, Age, Region)][, .(mean(Age)), by = c(\"Gender\", \"Region\")].  The statement can also begin by defining a variable, such as \"res = dt[Age < 50, .(Gender, Age, Region)]\".\n\n# i.statement:  a character value or expression providing the filtering i step.  Specifying \"Age < 50\" with dt.name = \"dt\" would lead to \"dt[Age < 50,]\".\n\n# j.statement:  a character value or expression providing the data.table j step, which performs calculations.  Specifying \"mean(Age)\" with dt.name = \"dt\" would lead to \"dt[, mean(Age)]\".\n\n# grouping.variables:  a character vector with the names of the variables to group by.\n\n# grouping.type:  a character value indicating whether the resulting table should be sorted (grouping.type = \"keyby\") or presented as is (grouping.type = \"by\"), with \"keyby\" as the default.\n\n# Note:  This function works entirely with character values.  It does not directly evaluate any of these commands.  To do so on a resulting value called the.statement, you can use eval(parse(text = the.statement)) to run the data.table calculation.  Alternatively, you can call eval.dt.statement.\n\ncreate.dt.statement <- function(dt.name, i.statement = NULL, j.statement = NULL, grouping.variables = NULL, sortby.group = TRUE, envir = .GlobalEnv, ...){\n  \n  check.dt.exists(dt.name = dt.name, envir = envir)\n  \n  if(is.null(i.statement) & is.null(j.statement)){\n    return(dt.name)\n  }\n  if(is.null(i.statement) | mean(i.statement == \"TRUE\") == 1 | mean(i.statement == TRUE) == 1){\n    i.statement <- \"\"\n  }\n  \n  first.space <- \" \"\n  second.comma <- \", \"\n  \n  if(!is.null(grouping.variables)){\n#    grouping.variables <-\n#      eval(unique(grouping.variables[grouping.variables %in% names(get(dt.name))]))\n    \n    by.statement <- create.grouping.statement(dt.name = dt.name, grouping.variables = grouping.variables, sortby.group = sortby.group)\n  }\n  \n  if(is.null(grouping.variables)){\n    second.comma <- \"\"\n    by.statement <- \"\"\n  }\n  if(is.null(j.statement)){\n    j.statement <- \"\"\n    by.statement <- \"\"\n  }\n  \n  if(j.statement == \"\" & by.statement == \"\"){\n    first.space <- \"\"\n  }\n  \n  calculated.statement <- sprintf(\"%s[%s,%s%s%s%s]\", dt.name, i.statement, first.space, j.statement, second.comma, by.statement)\n  \n  return(calculated.statement)\n}\n\n\n# Internal Function\n\n# creates the i step of a data.table statement.\ncreate.i.statement <- function(dt.name, the.filter = NULL, envir = .GlobalEnv){\n\n  if(is.null(x = the.filter) == TRUE){\n    return(\"\")\n  }\n  \n  logical.filter <- is.logical(x = the.filter)\n  numeric.filter <- is.numeric(x = the.filter) | is.integer(x = the.filter)\n  character.or.expression.filter <- is.character(x = the.filter) | is.expression(x = the.filter)\n  \n  if(logical.filter == F & numeric.filter == F & character.or.expression.filter == F){\n    warning(sprintf(\"The value of the.filter must be either a) a vector that is logical (TRUE/FALSE), numeric, or integer or b) a character value or expression providing a logical test to apply to the data.  Since the.filter was not specified in this way, no filtering will be applied.\"))\n    i.statement <- NULL\n  }\n  \n  if(character.or.expression.filter == TRUE){\n    i.statement <- as.character(x = the.filter)\n  }\n  \n  if(logical.filter == TRUE | numeric.filter == TRUE){\n    n <- nrow(get(x = dt.name, envir = envir))\n    \n    if(logical.filter == TRUE){\n      len.filter <- length(the.filter)\n      if(len.filter == n){\n        i.statement <- reduce.vector.expression(x = which(the.filter == TRUE))\n      }\n      if(len.filter != n){\n        warning(sprintf(\"The values of the.filter were specified as a logical (TRUE/FALSE) vector, but it was not the same length as nrow(%s).  No filtering will be performed.\", dt.name))\n        i.statement <- NULL\n      }\n    }\n    if(numeric.filter == TRUE){\n      included.rows <- the.filter[the.filter %in% 1:n]\n      num.included.rows <- length(included.rows)\n      \n      if(num.included.rows == 0){\n        i.statement <- NULL\n      }\n      if(num.included.rows == 1){\n        i.statement <- sprintf(\"%d\", included.rows)\n      }\n      if(num.included.rows > 1){\n        i.statement <- reduce.vector.expression(x = included.rows)\n      }\n    }\n  }\n  \n  return(i.statement)\n}\n\n\n# Internal Function\n\n# creates the by or keyby step of a data.table statement.\n\ncreate.grouping.statement <- function(dt.name, grouping.variables, sortby.group = TRUE){\n  check.dt.exists(dt.name = dt.name)\n  all.dt.names <- names(get(dt.name))\n  \n  statement.type <- \"by\"\n  if(sortby.group == TRUE){\n    statement.type <- \"keyby\"\n  }\n  \n  gv <- grouping.variables\n  \n  num.gv <- length(gv)\n  \n  if(length(gv) == 1 & gv[1] %in% all.dt.names){\n    grouping.statement <- sprintf(\"%s = %s\", statement.type, gv)\n  }\n  if(length(gv) > 1 | !(gv[1] %in% all.dt.names)){\n    all.gv.in.names <- mean(grouping.variables %in% all.dt.names) < 1\n    if(all.gv.in.names == T){\n      use.case <- \"list\"\n      gv[gv %in% all.dt.names] <- add.backtick(x = gv[gv %in% all.dt.names])\n    }\n    if(all.gv.in.names == F){\n      use.case <- \"c\"\n      gv <- sprintf(\"'%s'\", gv)\n    }\n    grouping.statement <- sprintf(\"%s = %s(%s)\", statement.type, use.case, paste(gv, collapse = \", \"))\n  }\n  \n  return(grouping.statement)\n  \n}\n",
    "created" : 1607306986826.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2951030785",
    "id" : "49DC308B",
    "lastKnownWriteTime" : 1605109743,
    "last_content_update" : 1605109743,
    "path" : "~/Desktop/DTwrappers Draft/DTwrappers/R/create.dt.statement.R",
    "project_path" : "R/create.dt.statement.R",
    "properties" : {
    },
    "relative_order" : 25,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}