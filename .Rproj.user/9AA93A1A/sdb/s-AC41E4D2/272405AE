{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Introduction to DTwrappers\"\nauthor: ''\ndate: '`r Sys.Date()`'\noutput:\n  html_document: default\n  rmarkdown::html_vignette: default\nvignette: >\n  %\\VignetteIndexEntry{Introduction to DTwrappers}\n  %\\VignetteEngine{knitr::rmarkdown}\n  %\\VignetteEncoding{UTF-8}\n---\n\n```{r, include = FALSE}\nknitr::opts_chunk$set(\n  collapse = TRUE,\n  comment = \"#>\"\n)\n```\n\n### CONTEXT\n\n\n```{r setup, echo=FALSE}\n#library(getDTeval)\nn <- nrow(iris)\ndt.name <- \"dat\"\ndat <- data.table::as.data.table(x = iris[sample(x = 1:n, size = n, replace = F),])\ndat\n```\n\n### INTRODUCTION\n\nProgrammatic designs build coding statements with flexible structures that can easily be modified.  The best practices of software design recommend using variables to store certain values (e.g. constants or thresholds) that will be used in calculations.  The same principle can apply to the use of the names of variables in a data.frame object.  As an example, we will consider two approaches to calculating a simple mean and constructing a new variable.  The data used here will be based on the **snack.dat** data from the **formulaic** package (<https://cran.r-project.org/package=formulaic>):\n\n```{r simple_average_approaches}\ndat <- data.table::data.table(formulaic::snack.dat)\nthreshold.age <- 35\n## Approach 1\ndat[, mean(Age)]\ndat[, youngest_cohort := (Age < threshold.age)]\n## Approach 2\nage.name <- \"Age\"\nyoungest.cohort.name <- \"youngest_cohort\"\ndat[, mean(get(age.name))]\ndat[, eval(youngest.cohort.name) := (get(age.name) < threshold.age)]\n```\n\n\nIn the second approach, the **get()** and **eval()** functions are used to convert previously defined variables into quantities that can be used in the calculations.  Within the dat object, using the get function will locate a variable with the corresponding name and return the vector of values for use in the computations of the mean or the logical comparison of ages to a threshold.  Meanwhile, the eval function allows us to specify the name of a new variable that will be added to the dat object.\n\nProgrammatic designs with the get() and eval() functions facilitate calculations in functions and in dynamic applications.  Even for basic analyses, this design creates greater flexibility for possible changes.  If the name of the Age variable were later changed to another value (e.g. Age_Years), the program could be adapted with a simple modification to the age.name variable.  Any downstream use of the Age variable through calls of get() or eval() to age.name would automatically adapt to the change.\n\nHowever, programmatic designs can lead to reduced runtime efficiency.  In the case of simple calls to the get() function, the performance can greatly decrease.  The following example demonstrates the associated reductions in efficiency in the case of calculating a grouped average.\n\n```{r runtime_comparison}\nage.name <- \"Age\"\ngender.name <- \"Gender\"\nregion.name <- \"Region\"\nset.seed(seed = 293)\nsampledat <- dat[sample(x = 1:.N, size = 10^6, replace = TRUE)]\ntimes <- 50\nt1 <-\n  microbenchmark::microbenchmark(sampledat[, .(mean_age = mean(Age)), keyby = c(\"Gender\", \"Region\")], times = times)\nt2 <-\n  microbenchmark::microbenchmark(sampledat[, .(mean_age = mean(get(age.name))), keyby = c(gender.name, region.name)], times = times)\n                                 \n                                 \nresults <-\n  data.table::data.table(\n    Classic_Mean = mean(t1$time),\n    Classic_Median = median(t1$time),\n    Programmatic_Mean = mean(t2$time),\n    Programmatic_Median = median(t2$time)\n  ) / 10 ^ 9\nresults[, Effect_Median := Programmatic_Median/Classic_Median]\nround(x = results, digits = 4)\n```\n\nFor larger sample sizes and more complex calculations, the effect of programmatic designs can significantly increase the running time complexity.\n\nThe **getDTeval** package was designed to overcome the trade-offs between programmatic designs and running time efficiency.  The package creates a means of translating calls to get() and eval() into more optimized coding statements.  In doing so, the package not only resolves many observed trade-offs between speed and efficiency; it also creates opportunities to expand the areas in which programmatic designs may be used in common coding applications.\n\n\n## Methods\n\nThe getDTeval package introduces two functions: **getDTeval::getDTeval** and **getDTeval::benchmark.getDTeval**.  The getDTeval() function is used to translate and evaluate coding statements into more optimized forms.  The benchmark.getDTeval() function then provides a means of comparing the run-time performance of a coding statement.\n\n\n### getDTeval()\n\nThe getDTeval() function facilitates the translation of the original coding statement to an optimized form for improved runtime efficiency without compromising on the programmatic coding design.  The function can either provide a translation of the coding statement, directly evaluate the translation to return a coding result, or provide both of these outputs.\n\n#### parameter descriptions\n\n- **the.statement** refers to the original coding statement which needs to be translated to an optimized form.  This value may be entered as either a character value or as an expression.\n\n- **return.as** refers to the mode of output. It could return the results as a coding statement (return.as = \"code\"), an evaluated coding result (return.as = \"result\", which is the default value), or a combination of both (return.as = \"all\"). \n\n- **coding.statements.as** determines whether the coding statements provided as outputs are returned as expression objects (return.as = \"expression\") or as character values (return.as = \"character\", which is the default).\n\n- **eval.type** specifies whether the coding statement will be evaluated in its current form (eval.type = \"as.is\") or in an optimized form (eval.type = \"optimized\", the default setting).\n\n### Examples of getDTeval()\n\nThe following examples demonstrate applications of the getDTeval() function in common calculations.\n\n### Example 1:  Grouped Mean in data.table Using get() Statements\n\n```{r example_1}\nincome.name <- \"Income\"\ngender.name <- \"Gender\"\nthe.statement.1 <- \"dat[,.(mean_income=mean(get(income.name))), keyby = get(gender.name)]\"\n```\n\n#### Example 1a:  Translated Code\n\n```{r example_1a}\ngetDTeval(the.statement = the.statement.1, return.as = \"code\")\n```\n\n#### Example 1b:  Result\n\n```{r example 1b}\ngetDTeval(the.statement = the.statement.1, return.as = \"result\")\n```\n\n#### Example 1c:  Translations and Results\n\n```{r example 1c}\ngetDTeval(the.statement = the.statement.1, return.as = \"all\")\n```\n\n### Example 2:  Filtered and Grouped Mean with dplyr\n\n\n```{r example_2}\nlibrary(dplyr)\nincome.name <- \"Income\"\nregion.name <- \"Region\"\nawareness.name <- \"Awareness\"\nthreshold.income <- 75000\nthe.statement.2 <-\n  expression(\n    dat %>% filter(get(income.name) < threshold.income) %>% group_by(get(region.name)) %>% summarise(prop_aware = mean(get(awareness.name)))\n  ) \n```\n\nIn particular, note that **the.statement** can be entered as either an expression or as a character value.  When the coding statement itself includes quotation marks, some care should be taken to ensure that the statement is properly represented.  For instance, consider a coding statement like dat[, mean(Age), by = c('Region', 'Gender')].  Using double quotation marks for Region or Gender could create issues with writing this statement inside of a character value.  A convention such as only using single quotations inside of the coding statement could simplify the problem.  Otherwise, placing the coding statement in an expression ensures that any set of valid coding symbols may be used.\n\nIn the following examples, we will show how the code itself can be returned as either a character or as an expression.\n\n#### Example 2a:  Translations\n\n```{r example_2a}\ngetDTeval(the.statement = the.statement.2, return.as = \"code\", coding.statements.as = \"expression\")\ngetDTeval(the.statement = the.statement.2, return.as = \"code\", coding.statements.as = \"character\")\n```\n\n#### Example 2b:  Result\n\n```{r example_2b}\ngetDTeval(the.statement = the.statement.2, return.as = \"result\")\n```\n\n#### Example 1c:  Translations and Results\n\n```{r example_2c}\ngetDTeval(the.statement = the.statement.2, return.as = \"all\", coding.statements.as = \"expression\")\ngetDTeval(the.statement = the.statement.2, return.as = \"all\", coding.statements.as = \"character\")\n```\n\n\n### Example 3:  Running Code As Is or in Optimized Statements\n\nThe getDTeval() function also includes methods to run the code according to the original statement or in its optimized form.  This is a good way to double check that the coding translation performs as intended.  In the following example, we will demonstrate both kinds of calculations.  This includes the following preliminary steps:\n\n```{r example_3}\nthe.statement.3 <- \"tab <- dat[, .(prop_awareness = mean(get(awareness.name))), by = eval(region.name)]; data.table::setorderv(x = tab, cols = region.name, order = -1)\"\n```\n\n\n\n#### Example 3a:  Running Code As Is\n\nWhen the coding statement is evaluated with return.as = \"result\" or return.as = \"all\", then using eval.type = \"as.is\" means that the original coding statement is evaluated.\n\n```{r example_3a}\ngetDTeval(the.statement = the.statement.3, return.as = \"result\", eval.type = \"as.is\")\n```\n\n#### Example 3b:  Running the Translated Code\n\nWhen the coding statement is evaluated with return.as = \"result\" or return.as = \"all\", then using eval.type = \"optimized\" means that the translated coding statement is evaluated.\n\n```{r example_3b}\ngetDTeval(the.statement = the.statement.3, return.as = \"result\", eval.type = \"optimized\")\n```\n\n### Benchmarking with benchmark.getDTeval()\n\n\nbenchmark.getDTeval function facilitates comparisons of the running time complexity of calculations based on different forms of a coding statement.  The original statement's performance will be compared to the running time after the statement is translated using getDTeval().\n\n### parameter description\n\n- **the.statement** refers to the original coding statement, just as in getDTeval().\n- **times** The number of iterations to run the benchmarking experiment.\n- **seed** an integer value specifying the seed of the pseudorandom number generator.\n\n## An example to highlight the benchmark.getDTeval function\n\nTo highlight the application of the benchmark.getDTeval() function, we will use a sample of 1 million observations drawn with replacement from the snack.dat.\n\n### Example 4\n\nWe will be calculating the mean awareness of the survey's participants by region.  The benchmark.getDTeval() function will be used to compare the running times of the original programmatic coding statement and the translated statement.  This comparison also evaluates the time of the optimized statement, which would use the translated statement without the time required to translate it.\n\n```{r example_4}\nsample.dat <- dat[sample(x = 1:.N,\n                         size = 10 ^ 6,\n                         replace = TRUE)]\nthe.statement.4 <-\n  expression(sample.dat[, .(pct_awareness = mean(get(awareness.name)) * 100), keyby = get(region.name)])\nbenchmark.getDTeval(the.statement = the.statement.4,\n                    times = 50,\n                    seed = 282)\n```\n\nThe original coding statement uses calls to get() to generate results with a programmatic design.  In the median and average cases, the running time is substantially worse than using the more optimized statement.  There is a real trade-off between the flexibility of the programmatic design and the running time performance of directly naming the variables.  However, translating the programmatic design's coding statement using getDTeval() produces running times that are quite similar to what is produced while directly using the optimized statements.  These results suggest that getDTeval() can effectively eliminate these tradeoffs.\n\n\n## Benefits getDTeval\n\nThe getDTeval package offers a number of benefits to bridge the gap between the flexibility of coding statements and their runtime execution. These benefits are as follows:\n\n- Minimizing the running time complexity of the algorithms;\n- Using the available computing resources efficiently;\n- Ease of implementation for an analyst;\n- Translations that can improve the readability of coding designs;\n- Enhanced flexibility with programmatic designs for streamlined iterations and revision.\n\n\n## Extending the Capacity for Programmatic Designs\n\nThe getDTeval() function performs code translations of any calls to get() or eval() within a coding statement.  In some cases, this translation can enable the use of programmatic designs even when the original coding statement would not properly evaluate.  In the examples below, we will consider some examples that make use of this capability.\n\n### Example 5:  Using eval() in Calculated Quantities with data.table\n\nEarlier in this document, we provided examples in which the eval() function could be used to programmatically add new variables to a data.table object.  However, for calculated quantities inside of data.table's .() notation, this use of eval() would generate an error.  We can demonstrate this problem with the example below:\n\n- Here, we are using data.table to evaluate mean awareness by region. \n\nprop.awareness.name <- \"Proportion Aware\"\nawareness.name <- \"Awareness\"\nregion.name <- \"Region\"\ndat[,eval(mean.awareness.name) = mean(get(awareness.name)) * 100, keyby = get(region.name)]\n\nError: unexpected '=' in \"dat[,eval(mean.awareness.name) =\"\n\nHowever, we get the above stated error where eval function programmatically is not able to evaluate the desired calculation. \n\nTranslating this statement with getDTeval() would allow us to get the desired results:\n\n```{r ex_5_b, error = TRUE}\nthe.statement <- 'dat[, .(eval(mean.awareness.name) = mean(get(awareness.name)) * 100), keyby = get(region.name)]'\ngetDTeval(the.statement = the.statement, return.as = 'all')\n```\n\n\n\n### Example 6:  Using eval() in Calculated Quantities with dplyr\n\n\nIn a similar fashion to the previous example, the use of the dplyr package has settings in which using programmatic names for calculated quantities can generate errors.  This is demonstrated in the following example, which also uses getDTeval to resolve the issue.\n\n- Here, we are using dplyr to calculate mean awareness by region\n\ndat %>% group_by(get(region.name)) %>% summarize(eval(mean.awareness.name)=mean(get(awareness.name),na.rm=T))\n\nDplyr also generates the following error where '=' is not compatible to use with eval()\n\nError: unexpected '=' in \"dat %>% group_by(get(region.name)) %>% summarize(eval(mean.awareness.name)=\"\n\nHowever, getDTeval allows us to resolve this issue by making the necessary translation to the optimized coding form of the statement.\n\n```{r ex_6b}\nthe.statement<- 'dat %>% group_by(get(region.name)) %>% summarize(eval(mean.awareness.name)=mean(get(awareness.name),na.rm=T))'\ngetDTeval(the.statement = the.statement, return.as='all')\n```\n\n### Example 7: Programmatic Mutation with dplyr \n\nThe mutate() function of dplyr can be used to add a new column to a data.frame object.  This step cannot directly be used with a call to the eval() function.  In the following example, we will attempt to add a new variable that calculates the user's age in decades.\n\nage.decade.name <- \"Age_Decade\"\ndat[1:10,] %>% mutate(eval(age.decade.name) = floor(get(age.name)/10)) %>% select(eval(age.name), eval(age.decade.name))\n\nUsing mutate() from the dplyr package to evaluate age decade as shown above generates the following error:\n\nError: unexpected '=' in \"dat[1:10,] %>% mutate(eval(age.decade.name) =\"\n\nHowever, getDTeval() offers an acceptable translation of the programmatic design:\n\n```{r example_7b}\nthe.statement <- 'dat[1:10,] %>% mutate(eval(age.decade.name) = floor(get(age.name)/10)) %>% select(eval(age.name), eval(age.decade.name))'\ngetDTeval(the.statement = the.statement, return.as = 'all')\n```\n\n#### Example 8: Improving Readability of Grouped Calculations in dplyr\n\nWhen the get() function is used in dplyr's group_by() function, the resulting name of the column is based on the programmatic statement.  This is demonstrated with the following example, which calculates the average satisfaction score by the geographic region:\n\n```{r example_8a}\ndat %>% group_by(get(region.name)) %>% summarize(mean_satisfaction = mean(get(satisfaction.name), na.rm=T))\n```\n\n\n\n```{r example_8b, warning=FALSE}\nthe.statement<- 'dat %>% group_by(get(region.name)) %>% summarize(eval(sprintf(\"Mean %s\", satisfaction.name)) = mean(get(satisfaction.name), na.rm=T))'\ngetDTeval(the.statement = the.statement, return.as='all')\n```\n\n\nThis result adds greater readability to the resulting table.\n\n## Notes\n\n- The usage of getDTeval to find instances of get or eval should be limited to only the get() and eval() functions and not applied to the extended functions such as dynGet, mget, evalq, eval.parent etc. \n\n- Also, as an extension to the above mentioned disclaimer, the current design of getDTeval function might encounter translation issues with functions that end in get( or eval and may create errors when other functions that end in these prefixes are used. \n\nTo exemplify let us examine the following case:\n\nmean.get <- function(x){\n  return(mean(x))\n}\ngetDTeval(the.statement = \"mean.get(1:5)\", return.as = \"result\")\n\nHere mean.get() is a customized function created to evaluate the mean of an objext x. \n  \nHowever, the use of mean.get() generates a translation error.  Any coding statement that includes the substring **get(** or **eval(** would trigger an attempt at translation by getDTeval().\n\nA workaround this issue would be to add a space between the mean.get( functionality and the parenthesis as follows:\n\n```{r eample 9b}\nmean.get <- function(x){\n  return(mean(x))\n}\ngetDTeval(the.statement = \"mean.get (1:5)\", return.as = \"result\")\n```\n\nThis addition of space allows the getDteval() function to perform the required translation effectively.  This comes with a caveat that legitimate calls to get() and eval() functions will not be translated if there is a space before the parenthesis. Therefore, the user should be careful in using the custom or extended functions involving get( or eval( while using the getDTeval package. \n\n\n## Conclusion\n\nThis document has demonstrated the applications of the getDTeval package.  Through translations of coding statements, the getDTeval() function is able to incorporate programmatic designs while approximating the running time performance of more optimized code.  The method allows the user to construct programmatic statements that would be useful but are not fully supported by some existing packages.  Furthermore, because the method can show the resulting translation, there is an excellent opportunity to study the different ways of constructing a coding statement.  Meanwhile, the benchmark.getDTeval() function provides a direct means of comparing the typical times to evaluate a coding statement with and without programmatic designs relative to a more optimized benchmark.\n\nAnalyses that make use of customized functions and dynamic applications can benefit from the use of get() and eval().  The observed trade-offs between flexibility and speed can be largely overcome through the use of the getDTeval package.  This also suggests greater opportunities to employ translations of code to further improve the performance of coding styles in R.\n\n",
    "created" : 1606443363020.000,
    "dirty" : false,
    "encoding" : "",
    "folds" : "",
    "hash" : "3297784338",
    "id" : "272405AE",
    "lastKnownWriteTime" : 9,
    "last_content_update" : 1607302128258,
    "path" : null,
    "project_path" : null,
    "properties" : {
        "last_setup_crc32" : "",
        "tempName" : "Untitled1"
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}