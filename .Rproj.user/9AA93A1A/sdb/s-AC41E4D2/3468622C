{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Introduction to DTwrappers\"\nauthor: ''\ndate: '`r Sys.Date()`'\noutput:\n  html_document: default\n  rmarkdown::html_vignette: default\nvignette: >\n  %\\VignetteIndexEntry{Introduction to DTwrappers}\n  %\\VignetteEngine{knitr::rmarkdown}\n  %\\VignetteEncoding{UTF-8}\n---\n\n```{r, include = FALSE}\nknitr::opts_chunk$set(\n  collapse = TRUE,\n  comment = \"#>\"\n)\n```\n\nAs an open-source language, R has many competing methods of data processing.  Many of these are structured using either sequential coding statements or within sophisticated queries.  A beginning level user of R may simultaneously face all of the challenges of understanding the structure of data, learning new methods of analysis, and adopting the syntax of computer programming.  While the existing methods can be effective, appealing to other audiences and learning styles would be quite beneficial for a rapidly expanding population of data analysts and scientists.  The DTwrappers package is therefore proposed as a supplement to the existing methods that can be effective in this setting.\n\nThis vignette aims to introduce a certain set of executable functions within the DTwrappers package which make data manipulation easier by using some data.table translations. To showcase the benefits of such functions, this vignette will go through examples from the **iris** dataset\n\n\n```{r setup, echo=FALSE}\n#library(DTwrappers)\nn <- nrow(iris)\ndt.name <- \"dat\"\ndat <- data.table::as.data.table(x = iris[sample(x = 1:n, size = n, replace = F),])\nhead(dat)\n```\n\nThe data gives the measurements in centimeters of the variables sepal length and width and petal length and width, respectively, for 50 flowers from each of 3 species of iris. The species are Iris setosa, versicolor, and virginica.\n\n\n\n## Introduction\n\nThe DTwrappers package was developed to produce simplified wrapper functions for the data.table package.  Its capabilities encompass a broad range of data processing methods.  This package aims to achieve several goals:\n\n1) Create a simplified syntax for data processing that minimizes the need for complex coding statements, all with the goal of helping beginning level R programmers learn to work with the language and to analyze data.\n\n2) Provide access to a wide range of data processing methods.\n\n3) Utilize data.table's methods in calculations to provide competitive speed and memory efficiency in analysis.\n\n4) Teach users the syntax of data.table's methods by providing translated coding statements for the calculations performed.\n\n\n###  Applications of DTwrapper functions\n\nRange of Offerings\n\nThe DTwrappers package offers the following methods:\n\n* dt.choose.rows:  Extracting a subset of the rows of the data.\n* dt.choose.cols:  Extracting a subset of the variables (columns of the data).\n* dt.count.rows:  Showing how many records are in the data, either overall or in groups.\n* dt.define.variable:  Adding a new variable to an existing data.frame.\n* dt.remove.variables:  Removing one or more variables from an existing data.frame.\n* dt.sort:  Sorting a data.frame based upon a the values of specific variables.\n* dt.calculate:  Applying R's functions to one or more variable, either separately or in combination.\n\nMany of these functions can be called quite simply, but they include many features that can account for more complex queries.  For instance, dt.calculate can be used for simple calculations of a mean or standard deviation, but these measures can be applied on specified subsets of the data, performed separately in subgroups, and scaled to simultaneous calculations on a large number of variables.\n\nNow we will dive into each of these and exemplify using examples:\n\n#### 1) Function: dt.count.rows\n\nThis function counts the number of qualifying rows in a data.table or data.frame object. It is built as a wrapper function of data.table's filter (the i step).  These counts may be comprehensive for the entire table or conducted in groups.  The full data can also be filtered for qualifying cases prior to conducting the counts.\n\nParameters:\n\ndt.name: a character value specifying the name of a data.frame or data.table object to select data from\n\nthe.filter: a character value, numeric vector, logical vector, or expression stating the logical operations used to filter the data.  The filtering step will be applied prior to generating the counts. \n\ncount.name: a character value specifying the name of the column of counts in the resulting table.  This value defaults to \"N\" unless otherwise specified.\n\nreturn.as:  a character value specifying what output should be returned.  return.as = \"result\" provides the table of counts.  return.as = \"code\" provides a data.table coding statement that can generate the table of counts.  return.as = \"all\" provides both the resulting table and the code. \n\n\n##### Example 1a) Count Number of Rows in a dataset \n\n```{r Count the number of rows in the dataset iris}\ndt.count.rows(dt.name = \"dat\", count.name = \"Total Rows\", return.as = \"all\")\n```\n\n##### Example 1b) Count Number of Rows where Species is Setosa\n\n```{r Count number of rows where species is \"Setosa\"}\ndt.count.rows(dt.name = \"dat\", the.filter = \"Species == 'setosa'\", return.as = \"calculate\")\n```\n\n#### 2) Function: dt.choose.rows\n\n\n\n##### Example 2a) Choose first 3 rows of the dataset \n\n```{r}\n#dt.choose.rows(dt.name = \"dat\", the.filter = \"1:3\", return.as = 'result')\n```\n\n##### Example 2b) Choose rows of data for species with sepal length shorter than 4.4\n\n```{r}\ndt.choose.rows(dt.name = \"dat\", the.filter = \"Sepal.Length < 4.4\", return.as = \"all\")\n```\n\n#### 3) Function: dt.choose.cols\n\n##### Example 3a) Choose all the columns of the dataset for first 5 entries of dataset\n\n\n```{r}\ndt.choose.cols(dt.name = \"dat\", the.variables = \".\", the.filter = \"1:5\", return.as = \"all\")\n```\n\n##### Example 3b) Choose only specified columns of the dataset [Species and Sepal Length] for first 3 entries of dataset\n\n```{r}\ndt.choose.cols(dt.name = \"dat\", the.variables = c(\"Species\", \"Sepal.Length\"), the.filter = \"1:3\", return.as = \"all\")\n```\n\n##### Example 3c) Extract the first two rows of data for each species with its sepal length and width\n\n```{r}\ndt.choose.cols(dt.name = \"dat\", the.variables = c(\"Sepal.Length\", \"Sepal.Width\"), grouping.variables = \"Species\", first.k = 2, return.as = \"all\")\n```\n\n#### 4) Function: dt.define.variable\n\n##### Example 4a) Create a variable named Category with Iris as the value\n\n```{r}\ndt.define.variable(dt.name = \"dat\", variable.name = \"Category\", the.values = \"iris\", return.as = \"all\", specification = \"by.value\")\n```\n\n##### Example 4b) Creating a new variable with calculated expression, extracting maximum sepal length per species. \n\n```{r }\ndt.define.variable(dt.name = \"dat\", variable.name = \"Max_Sepal_Length_Species\", the.values = \"max(Sepal.Length)\", specification = \"by.expression\", grouping.variables = \"Species\", sortby.group = TRUE, return.as = \"all\")\n```\n\n#### 5) Function: dt.remove.variables\n\n##### Example 5a) Removing the Category column as defined in Eg 4a\n\n```{r}\ndt.remove.variables(dt.name = \"dat\", the.variables = c(\"Category\"), return.as = \"all\")\n```\n\n#### 6) Function: dt.sort\n\n```{r}\ndt.sort(dt.name = \"dat\", sorting.variables = c(\"Species\", \"Sepal.Length\"), sort.increasing = c(F), return.as = \"all\")\n```\n\n```{r}\ndt.sort(dt.name = \"dat\", sorting.variables = c(\"Species\", \"Sepal.Length\"), sort.increasing = c(T, F), return.as = \"all\")\n```\n\n\n\n\n\n\n\n\n#### 6) Function: dt.calculate\n\n##### Example 6a) Calculating Mean and Standard deviation of sepal length variable \n\n```{r}\ndt.calculate(dt.name = \"dat\", the.variables = c(\"Sepal.Length\"), the.functions = c(\"mean\", \"sd\"), return.as = \"all\")\n```\n\n##### Example 6b) Applying Calculations [Mean, standard deviation] for filtered data and grouped by a variable\n\n```{r}\ndt.calculate(dt.name = \"dat\", the.variables = c(\"Sepal.Length\"), the.functions = c(\"mean\", \"sd\"), the.filter = \"Sepal.Length < 0.9 * Max_Sepal_Length_Species\", grouping.variables = \"Species\", table.format = \"long\", return.as = \"all\")\n```\n\n##### Example 6c) Presenting the output of calculations in wide format\n\n```{r}\ndt.calculate(dt.name = \"dat\", the.variables = c(\"Sepal.Length\"), the.functions = c(\"mean\", \"sd\"), the.filter = \"Sepal.Length < 0.9 * Max_Sepal_Length_Species\", grouping.variables = \"Species\", table.format = \"wide\", return.as = \"all\")\n```\n\n##### Example 6d) Additional parameters to bring flexibility to the calculations [Removing Missing values while computing mean and standard deviation]\n\n```{r}\ndt.calculate(dt.name = \"dat\", the.variables = c(\"Sepal.Length\", \"Sepal.Width\"), the.functions = c(\"mean\", \"sd\"), table.format = \"long\", other.params = \"na.rm = T\", return.as = \"all\")\n```\n\n##### Example 6e) Ability to add customized functions in dt.calculate for desired calculations\n\n```{r}\n`triple mean` <- function(x, na.rm = T){\n  return(3 * mean(x = x, na.rm = na.rm))\n}\n\n# Customized functions can then be called in the.functions just like established methods.\ndt.calculate(dt.name = \"dat\", the.variables = c(\"Sepal.Length\", \"Sepal.Width\"), the.functions = c(\"mean\", \"sd\", \"triple mean\"), grouping.variables = \"Species\", table.format = \"long\", return.as = \"all\")\n```\n\n##### Example 6f) Efficient use of dt.calculate to tackle condition related queries with ease \n\n\n\n```{r}\ndt.calculate(dt.name = \"dat\", the.variables = c(\"Sepal.Width\", \"Petal.Width\"), the.functions = c(\"mean\", \"sd\", \"triple mean\"), the.filter = \"Sepal.Length < 6\", grouping.variables = c(\"Below_Average_Sepal_Length = (Sepal.Length < mean(Sepal.Length))\"), table.format = \"long\", return.as = \"all\")\n```\n\n```{r}\ndt.calculate(dt.name = \"dat\", the.variables = c(\"Sepal.Width\", \"Petal.Width\"), the.functions = c(\"rowSums\", \"rowMeans\"), individual.variables = F)\n```\n\n```{r}\n## linear regression \ndt.calculate(dt.name = \"dat\", the.functions = \"lm\", other.params = \"formula = Sepal.Length ~ Sepal.Width + Petal.Length + Petal.Width\", return.as = \"all\", individual.variables = F, output.as.table = F)\n```\n\n```{r}\nget.lm.coefs <- function(formula, data){\n  require(data.table)\n  mod <- lm(formula = formula, data = data)\n  the.coefs <- as.data.table(x = summary(mod)$coefficients, keep.rownames = TRUE)\n  setnames(x = the.coefs, old = \"rn\", new = \"Variable\")\n  return(the.coefs)\n}\n\ndt.calculate(dt.name = \"dat\", the.functions = \"get.lm.coefs\", grouping.variables = \"Species\", other.params = \"formula = Sepal.Length ~ Sepal.Width + Petal.Length + Petal.Width\", return.as = \"all\", individual.variables = F, add.function.name = F)\n```\n\n\n\n```{r}\n\n```\n\n",
    "created" : 1607305319470.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2573225791",
    "id" : "3468622C",
    "lastKnownWriteTime" : 1612331534,
    "last_content_update" : 1612331534398,
    "path" : "~/Desktop/test-1.Rmd",
    "project_path" : null,
    "properties" : {
        "last_setup_crc32" : "E049066F801f606",
        "tempName" : "Untitled4"
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}